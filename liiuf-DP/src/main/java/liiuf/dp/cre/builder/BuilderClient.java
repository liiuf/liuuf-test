package liiuf.dp.cre.builder;

import liiuf.dp.cre.builder.exp01.Director;
import liiuf.dp.cre.builder.exp01.bui.Builder;
import liiuf.dp.cre.builder.exp01.bui.ConcreteBuilder1;
import liiuf.dp.cre.builder.exp01.pro.Product1;
import org.junit.Test;

/**
 * @简介
 * - 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
 * - 生成器模式是一种创建型设计模式， 使你能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。
 * - 生成器与其他创建型模式的不同之处在于：它让你能创建不遵循相同接口的产品。
 *
 * @优缺点
 * #优点
 * - 你可以分步创建对象，暂缓创建步骤或递归运行创建步骤。
 * - 生成不同形式的产品时，你可以复用相同的制造代码。
 * - 单一职责原则。你可以将复杂构造代码从产品的业务逻辑中分离出来。
 * - 封装性，使用建造者模式可以使客户端不必知道产品内部组成的细节。
 * - 建造者相互独立，容易扩展，并且可以对建造过程逐步细化，而不对其他的模块产生任何影响。
 * #缺点
 * - 由于该模式需要新增多个类，因此代码整体复杂程度会有所增加。
 *
 * @使用场景
 * - 使用生成器模式可避免 “重叠构造函数 （telescoping constructor）” 的出现。假设你的构造函数中有十个可选参数，那么调用该函数会非常不方便；
 *  因此，你需要重载这个构造函数，新建几个只有较少参数的简化版。但这些构造函数仍需调用主构造函数，传递一些默认数值来替代省略掉的参数。生成器模式
 *  让你可以分步骤生成对象，而且允许你仅使用必须的步骤。应用该模式后，你再也不需要将几十个参数塞进构造函数里了。
 * - 当你希望使用代码创建不同形式的产品（例如石头或木头房屋）时，可使用生成器模式。如果你需要创建的各种形式的产品，它们的制造过程相似且仅有
 *  细节上的差异，此时可使用生成器模式。基本生成器接口中定义了所有可能的制造步骤，具体生成器将实现这些步骤来制造特定形式的产品。同时，主管类将
 *  负责管理制造步骤的顺序。
 * - 使用生成器构造组合树或其他复杂对象。生成器模式让你能分步骤构造产品。你可以延迟执行某些步骤而不会影响最终产品。你甚至可以递归调用这些步骤，
 *  这在创建对象树时非常方便。生成器在执行制造步骤时，不能对外发布未完成的产品。这可以避免客户端代码获取到不完整结果对象的情况。
 * - 相同的方法，不同的执行顺序，产生不同的事件结果时，可以采用建造者模式。
 * - 多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时，则可以使用该模式。
 * - 产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能，这个时候使用建造者模式非常合适。
 * - 在对象创建过程中会使用到系统中的一些其他对象，这些对象在产品对象的创建过程中不易得到时，也可以采用建造者模式封装该对象的创建过程。
 *  该种场景只能是一个补偿方法，因为一个对象不容易获得，而在设计阶段竟然没有发觉，而要通过创建者模式柔化创建过程，本身已经违反设计的最初目标。
 *
 * @思路
 * - 清晰地定义通用步骤，确保它们可以制造所有形式的产品。否则你将无法进一步实施该模式。
 * - 在基本生成器接口中声明这些步骤。
 * - 为每个形式的产品创建具体生成器类，并实现其构造步骤。
 * - 不要忘记实现获取构造结果对象的方法。你不能在生成器接口中声明该方法，因为不同生成器构造的产品可能没有公共接口，因此你就不知道该方法
 *  返回的对象类型。但是，如果所有产品都位于单一类层次中，你就可以安全地在基本接口中添加获取生成对象的方法。
 * - 考虑创建主管类。它可以使用同一生成器对象来封装多种构造产品的方式。
 * - 客户端代码会同时创建生成器和主管对象。构造开始前，客户端必须将生成器对象传递给主管对象。通常情况下，客户端只需调用主管类构造函数一次即可。
 *  主管类使用生成器对象完成后续所有制造任务。还有另一种方式，那就是客户端可以将生成器对象直接传递给主管类的制造方法。
 * - 只有在所有产品都遵循相同接口的情况下，构造结果可以直接通过主管类获取。否则，客户端应当通过生成器获取构造结果。
 */
public class BuilderClient {
    /**
     * @分类
     * - 生成器（Builder）接口声明在所有类型生成器中通用的产品构造步骤。
     * - 具体生成器（Concrete Builders）提供构造过程的不同实现。具体生成器也可以构造不遵循通用接口的产品。
     * - 产品（Products）是最终生成的对象。由不同生成器构造的产品无需属于同一类层次结构或接口。
     * - 主管（Director）类定义调用构造步骤的顺序，这样你就可以创建和复用特定的产品配置。
     * - 客户端（Client）必须将某个生成器对象与主管类关联。一般情况下，你只需通过主管类构造函数的参数进行一次性关联即可。此后主管类就能
     *  使用生成器对象完成后续所有的构造任务。但在客户端将生成器对象传递给主管类制造方法时还有另一种方式。在这种情况下，你在使用主管类生产产品时
     *  每次都可以使用不同的生成器。
     */
    @Test
    public void testBuilder() {
        Builder b = new ConcreteBuilder1();
        // 客户端代码会创建生成器对象并将其传递给主管，然后执行构造过程。最终结果将需要从生成器对象中获取。
        Director d = new Director(b);
        d.make("simple");
        // 最终产品通常需要从生成器对象中获取，因为主管不知晓具体生成器和产品的存在，也不会对其产生依赖。
        Product1 p = (Product1) b.getProduct();
    }
}