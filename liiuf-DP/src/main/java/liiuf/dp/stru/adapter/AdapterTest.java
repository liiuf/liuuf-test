package liiuf.dp.stru.adapter;

import liiuf.dp.stru.adapter.cla.tar.ConcreteTarget;
import liiuf.dp.stru.adapter.cla.tar.Target;
import liiuf.dp.stru.adapter.obj.Adapter;
import liiuf.dp.stru.adapter.obj.Service;
import org.junit.Test;

/**
 * @介绍：
 * - 将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。
 * - 适配器模式是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。
 *
 * @优缺点：
 * #优点
 * - 单一职责原则你可以将接口或数据转换代码从程序主要业务逻辑中分离。
 * - 开闭原则。增加了类的透明性，只要客户端代码通过客户端接口与适配器进行交互，你就能在不修改现有客户端代码的情况下在程序中添加新类型的适配器。
 * - 提高了复用性，源角色在原有的系统中还是可以正常使用，而在目标角色中也可以充当新的演员。
 * - 灵活性非常好，若不想要适配器，没问题，删除掉这个适配器就可以了，其他的代码都不用修改，基本上就类似一个灵活的构件，想用就用，不想就卸载。
 * #缺点
 * - 代码整体复杂度增加，因为你需要新增一系列接口和类。有时直接更改服务类使其与其他代码兼容会更简单。
 * - 注意
 * - 适配器模式最好在详细设计阶段不要考虑它，它不是为了解决还处在开发阶段的问题，而是解决正在服役的项目问题，没有一个系统分析师会在做详细设计的
 *  时候考虑使用适配器模式，这个模式使用的主要场景是扩展应用中，系统扩展了，不符合原有设计的时候才考虑通过适配器模式减少代码修改带来的险。
 * - 项目一定要遵守依赖倒置原则和里氏替换原则，否则即使在适合使用适配器的场合下，也会带来非常大的改造。
 *
 * @使用场景：
 * - 当你希望使用某个类，但是其接口与其他代码不兼容时，可以使用适配器类。适配器模式允许你创建一个中间层类，其可作为代码与遗留类、
 *  第三方类或提供怪异接口的类之间的转换器。
 * - 如果需要复用这样一些类，他们处于同一个继承体系，并且他们又有了额外的一些共同的方法，但是这些共同的方法不是所有在这一继承体系中的子类所具有的共性。
 *  你可以扩展每个子类，将缺少的功能添加到新的子类中。但是，你必须在所有新子类中重复添加这些代码，这样会使得代码有坏味道。
 *
 * @思路：
 * - 确保至少有两个类的接口不兼容：
 *  一个无法修改（通常是第三方、 遗留系统或者存在众多已有依赖的类）的功能性服务类。
 *  一个或多个将受益于使用服务类的客户端类。
 * - 声明客户端接口，描述客户端如何与服务交互。
 * - 创建遵循客户端接口的适配器类。所有方法暂时都为空。
 * - 在适配器类中添加一个成员变量用于保存对于服务对象的引用。通常情况下会通过构造函数对该成员变量进行初始化，但有时在调用其方法时将该变量传递给适配器会更方便。
 * - 依次实现适配器类客户端接口的所有方法。适配器会将实际工作委派给服务对象，自身只负责接口或数据格式的转换。
 * - 客户端必须通过客户端接口使用适配器。这样一来，你就可以在不影响客户端代码的情况下修改或扩展适配器。
 */
public class AdapterTest {
    /**
     * 对象适配器：适配器实现了其中一个对象的接口，并对另一个对象进行封装。
     * - 客户端（Client）是包含当前程序业务逻辑的类。
     * - 客户端接口（Client Interface）描述了其他类与客户端代码合作时必须遵循的协议。
     * - 服务（Service）中有一些功能类（通常来自第三方或遗留系统）。客户端与其接口不兼容，因此无法直接调用其功能。
     * - 适配器（Adapter） 是一个可以同时与客户端和服务交互的类：它在实现客户端接口的同时封装了服务对象。适配器接受客户端通过适配器接口发起的调用，
     *  并将其转换为适用于被封装服务对象的调用。
     * - 客户端代码只需通过接口与适配器交互即可，无需与具体的适配器类耦合。因此，你可以向程序中添加新类型的适配器而无需修改已有代码。
     *  这在服务类的接口被更改或替换时很有用：你无需修改客户端代码就可以创建新的适配器类。
     */
    @Test
    public void testObj() {
        Service service = new Service();
        Adapter adapter = new Adapter(service);
        adapter.method();
    }

    /**
     * 类适配器：适配器同时继承两个对象的接口，Java中可以使用接口+继承类的方式实现。
     * - Target角色定义把其他类转换为何种接口，也就是我们的期望接口；
     * - Adaptee角色定义把谁转换成目标角色，这个“谁”就是源角色，它是已经存在的、运行良好的类或对象。
     * - Adapter角色定义如何把源角色转换为目标角色。
     */
    @Test
    public void testClazz() {
        Target target = new ConcreteTarget();
        target.request();
        System.out.println("-------------------------");
        Target target2 = new liiuf.dp.stru.adapter.cla.adap.Adapter();
        target2.request();
    }
}