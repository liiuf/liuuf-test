package liiuf.dp.stru.facade;

import liiuf.dp.stru.facade.fac.Facade;
import org.junit.Test;

/**
 * @介绍：
 * - 要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。
 * - 外观模式（门面模式）是一种结构型设计模式， 能为程序库、 框架或其他复杂类提供一个简单的接口。
 *
 * @分类：
 * - 外观（Facade） 提供了一种访问特定子系统功能的便捷方式，其了解如何重定向客户端请求，知晓如何操作一切活动部件。
 * - 创建附加外观 （Additional Facade） 类可以避免多种不相关的功能污染单一外观，使其变成又一个复杂结构。客户端和其他外观都可使用附加外观。
 * - 复杂子系统（Complex Subsystem）由数十个不同对象构成。如果要用这些对象完成有意义的工作，你必须深入了解子系统的实现细节，
 *  比如按照正确顺序初始化对象和为其提供正确格式的数据。子系统类不会意识到外观的存在，它们在系统内运作并且相互之间可直接进行交互。
 * - 客户端（Client） 使用外观代替对子系统对象的直接调用。
 *
 * @优缺点：
 * #优点
 * - 你可以让自己的代码独立于复杂子系统。
 * - 减少系统的相互依赖：想想看，如果我们不使用门面模式，外界访问直接深入到子系统内部，相互之间是一种强耦合关系，你死我就死，你活我才能活，
 *  这样的强依赖是系统设计所不能接受的，门面模式的出现就很好地解决了该问题，所有的依赖都是对门面对象的依赖，与子系统无关。
 * - 提高了灵活性：依赖减少了，灵活性自然提高了。不管子系统内部如何变化，只要不影响到门面对象，任你自由活动。
 * - 提高安全性：想让你访问子系统的哪些业务就开通哪些逻辑，不在门面上开通的方法，你休想访问到。
 * #缺点
 * - 外观可能成为与程序中所有类都耦合的上帝对象。
 * - 不符合开闭原则，对修改关闭，对扩展开放，看看我们那个门面对象吧，它可是重中之重，一旦在系统投产后发现有一个小错误，你怎么解决？
 *  完全遵从开闭原则，根本没办法解决。继承？覆写？都顶不上用，唯一能做的一件事就是修改门面角色的代码，这个风险相当大，
 *  这就需要大家在设计的时候慎之又慎，多思考几遍才会有好收获。
 *
 * @使用场景：
 * - 如果你需要一个指向复杂子系统的直接接口，且该接口的功能有限，则可以使用外观模式。子系统通常会随着时间的推进变得越来越复杂。
 *  即便是应用了设计模式，通常你也会创建更多的类。 尽管在多种情形中子系统可能是更灵活或易于复用的，但其所需的配置和样板代码数量将会增长得更快。
 *  为了解决这个问题，外观将会提供指向子系统中最常用功能的快捷方式，能够满足客户端的大部分需求。
 * - 如果需要将子系统组织为多层结构，可以使用外观。创建外观来定义子系统中各层次的入口。你可以要求子系统仅使用外观来进行交互，以减少子系统之间的耦合。
 *
 * @思路：
 * - 考虑能否在现有子系统的基础上提供一个更简单的接口。如果该接口能让客户端代码独立于众多子系统类，那么你的方向就是正确的。
 * - 在一个新的外观类中声明并实现该接口。外观应将客户端代码的调用重定向到子系统中的相应对象处。如果客户端代码没有对子系统进行初始化，
 *  也没有对其后续生命周期进行管理，那么外观必须完成此类工作。
 *
 * - 如果要充分发挥这一模式的优势，你必须确保所有客户端代码仅通过外观来与子系统进行交互。此后客户端代码将不会受到任何由子系统代码修改而造成的影响，
 *  比如子系统升级后，你只需修改外观中的代码即可。
 * - 如果外观变得过于臃肿，你可以考虑将其部分行为抽取为一个新的专用外观类。
 */
public class FacadeTest {
    @Test
    public void testFacade() {
        Facade facade = new Facade();
        facade.methodA();
        facade.methodB();
        facade.methodC();
    }
}