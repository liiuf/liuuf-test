package liiuf.dp.stru.composite;

import org.junit.Test;

/**
 * @介绍：
 * - 组合模式也叫合成模式，有时又叫做部分-整体模式，主要是用来描述部分与整体的关系，其定义如下：将对象组合成树形结构以表示“部分-整体”的层次结构，
 *  使得用户对单个对象和组合对象的使用具有一致性。
 * - 组合模式是一种结构型设计模式，你可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们。
 * - 如果应用的核心模型能用树状结构表示，在应用中使用组合模式才有价值。
 *
 * @分类：
 * - 组件（Component）接口描述了树中简单项目和复杂项目所共有的操作。
 * - 叶节点（Leaf）是树的基本结构，它不包含子项目。一般情况下，叶节点最终会完成大部分的实际工作，因为它们无法将工作指派给其他部分。
 * - 容器（Container）——又名 “组合 （Composite）”——是包含叶节点或其他容器等子项目的单位。容器不知道其子项目所属的具体类，
 *  它只通过通用的组件接口与其子项目交互。容器接收到请求后会将工作分配给自己的子项目，处理中间结果，然后将最终结果返回给客户端。
 * - 客户端（Client） 通过组件接口与所有项目交互。因此，客户端能以相同方式与树状结构中的简单或复杂项目交互。
 *
 * @优缺点：
 * #优点
 * - 你可以利用多态和递归机制更方便地使用复杂树结构。
 * - 开闭原则。无需更改现有代码，你就可以在应用中添加新元素，使其成为对象树的一部分。
 * #缺点
 * - 对于功能差异较大的类，提供公共接口或许会有困难。在特定情况下，你需要过度一般化组件接口，使其变得令人难以理解。
 * - 与依赖倒置原则冲突。
 * #注意
 * - 只要是树形结构，就要考虑使用组合模式，这个一定要记住，只要是要体现局部和整体的关系的时候，而且这种关系还可能比较深，考虑一下组合模式吧。
 *
 * @使用场景：
 * - 如果你需要实现树状对象结构，可以使用组合模式。组合模式为你提供了两种共享公共接口的基本元素类型：
 *  简单叶节点和复杂容器。容器中可以包含叶节点和其他容器。这使得你可以构建树状嵌套递归对象结构。
 * - 如果你希望客户端代码以相同方式处理简单和复杂元素，可以使用该模式。组合模式中定义的所有元素共用同一个接口。
 *  在这一接口的帮助下，客户端不必在意其所使用的对象的具体类。
 *
 * @思路：
 * - 确保应用的核心模型能够以树状结构表示。尝试将其分解为简单元素和容器。记住，容器必须能够同时包含简单元素和其他容器。
 * - 声明组件接口及其一系列方法，这些方法对简单和复杂元素都有意义。
 * - 创建一个叶节点类表示简单元素。程序中可以有多个不同的叶节点类。
 * - 创建一个容器类表示复杂元素。在该类中，创建一个数组成员变量来存储对于其子元素的引用。该数组必须能够同时保存叶节点和容器，
 *  因此请确保将其声明为组合接口类型。
 * - 实现组件接口方法时，记住容器应该将大部分工作交给其子元素来完成。
 * - 最后，在容器中定义添加和删除子元素的方法。
 * 记住， 这些操作可在组件接口中声明。这将会违反接口隔离原则，因为叶节点类中的这些方法为空。但是，这可以让客户端无差别地访问所有元素，
 * 即使是组成树状结构的元素。
 */
public class CompositeTest {
    @Test
    public void testComposite() {
        // 创建一个根节点
        Composite root = new Composite();
        root.execute();
        // 创建一个树枝
        Composite branch = new Composite();
        // 创建一个叶子节点
        Leaf leaf = new Leaf();
        // 建立整体
        root.add(branch);
        branch.add(leaf);
        // 递归遍历
        display(root);
    }

    public void display(Composite root) {
        for(Component c : root.getChildren()) {
            if(c instanceof Leaf) {
                c.execute();
            } else {
                display((Composite) c);
            }
        }
    }
}