package liiuf.dp.beh.cmd;

import liiuf.dp.beh.cmd.exp01.ConcreteCommand;
import liiuf.dp.beh.cmd.exp01.Invoker;
import liiuf.dp.beh.cmd.exp01.Receiver;
import org.junit.Test;

/**
 * @简介
 * - 将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。
 * - 命令模式是一种行为设计模式，它可将请求转换为一个包含与请求相关的所有信息的独立对象。该转换让你能根据不同的请求将方法参数化、
 *  延迟请求执行或将其放入队列中， 且能实现可撤销操作。
 * - 通过对象方式实现。
 *
 * @优缺点
 * #优点
 * - 单一职责原则。可以解耦触发和执行操作的类。
 * - 开闭原则。可以在不修改已有客户端代码的情况下在程序中创建新的命令。
 * - 可以实现撤销和恢复功能。
 * - 可以实现操作的延迟执行。
 * - 可以将一组简单命令组合成一个复杂命令。
 * #缺点
 * - 代码可能会变得更加复杂，因为你在发送者和接收者之间增加了一个全新的层次。
 *
 * @使用场景
 * - 如果你需要通过操作来参数化对象，可使用命令模式。命令模式可将特定的方法调用转化为独立对象。这一改变也带来了许多有趣的应用：你可以将命令作为方法
 *  的参数进行传递、将命令保存在其他对象中，或者在运行时切换已连接的命令等。
 * - 如果你想要将操作放入队列中、操作的执行或者远程执行操作，可使用命令模式。同其他对象一样，命令也可以实现序列化（序列化的意思是转化为字符串），
 *  从而能方便地写入文件或数据库中。一段时间后，该字符串可被恢复成为最初的命令对象。因此，你可以延迟或计划命令的执行。但其功能远不止如此！
 *  使用同样的方式，你还可以将命令放入队列、记录命令或者通过网络发送命令。
 * - 如果你想要实现操作回滚功能，可使用命令模式。尽管有很多方法可以实现撤销和恢复功能，但命令模式可能是其中最常用的一种。为了能够回滚操作，
 *  你需要实现已执行操作的历史记录功能。命令历史记录是一种包含所有已执行命令对象及其相关程序状态备份的栈结构。
 *  这种方法有两个缺点。首先，程序状态的保存功能并不容易实现，因为部分状态可能是私有的。你可以使用备忘录模式来在一定程度上解决这个问题。
 *  其次，备份状态可能会占用大量内存。因此，有时你需要借助另一种实现方式：命令无需恢复原始状态，而是执行反向操作。反向操作也有代价：它可能会很难甚至是无法实现。
 *
 * @思路
 * - 声明仅有一个执行方法的命令接口。
 * - 抽取请求并使之成为实现命令接口的具体命令类。每个类都必须有一组成员变量来保存请求参数和对于实际接收者对象的引用。所有这些变量的数值都必须通过命令构造函数进行初始化。
 * - 找到担任发送者职责的类。在这些类中添加保存命令的成员变量。发送者只能通过命令接口与其命令进行交互。发送者自身通常并不创建命令对象，而是通过客户端代码获取。
 * - 修改发送者使其执行命令，而非直接将请求发送给接收者。
 * - 客户端必须按照以下顺序来初始化对象：
 *  创建接收者。
 *  创建命令，如有需要可将其关联至接收者。
 *  创建发送者并将其与特定命令关联。
 */
public class CmdClient {
    /**
     * - 发送者（Sender）——亦称 “触发者（Invoker）”——类负责对请求进行初始化，其中必须包含一个成员变量来存储对于命令对象的引用。发送者触发命令，
     *  而不向接收者直接发送请求。注意，发送者并不负责创建命令对象：它通常会通过构造函数从客户端处获得预先生成的命令。
     * - 命令（Command） 接口通常仅声明一个执行命令的方法。
     * - 具体命令（Concrete Commands）会实现各种类型的请求。具体命令自身并不完成工作，而是会将调用委派给一个业务逻辑对象。但为了简化代码，
     *  这些类可以进行合并。接收对象执行方法所需的参数可以声明为具体命令的成员变量。你可以将命令对象设为不可变，仅允许通过构造函数对这些成员变量进行初始化。
     * - 接收者（Receiver）类包含部分业务逻辑。几乎任何对象都可以作为接收者。绝大部分命令只处理如何将请求传递到接收者的细节，接收者自己会完成实际的工作。
     * - 客户端（Client）会创建并配置具体命令对象。 客户端必须将包括接收者实体在内的所有请求参数传递给命令的构造函数。
     *  此后，生成的命令就可以与一个或多个发送者相关联了。
     */
    @Test
    public void testCmd() {
        Invoker invoker = new Invoker();
        Receiver receiver = new Receiver();
        ConcreteCommand command = new ConcreteCommand(receiver, "test");
        invoker.setCommand(command);
        invoker.executeCommand();
    }
}