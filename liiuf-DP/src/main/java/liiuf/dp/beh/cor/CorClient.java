package liiuf.dp.beh.cor;

import liiuf.dp.beh.cor.exp01.ConcreteHandler;
import liiuf.dp.beh.cor.exp01.ConcreteHandler2;
import liiuf.dp.beh.cor.exp01.ConcreteHandler3;
import liiuf.dp.beh.cor.exp01.Handler;
import org.junit.Test;

/**
 * @简介
 * - 使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。
 * - 责任链模式是一种行为设计模式， 允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。
 *
 * @分类
 * - 处理者（Handler） 声明了所有具体处理者的通用接口。该接口通常仅包含单个方法用于请求处理， 但有时其还会包含一个设置链上下个处理者的方法。
 * - 基础处理者（Base Handler）是一个可选的类，你可以将所有处理者共用的样本代码放置在其中。通常情况下，该类中定义了一个保存对于下个处理者
 *  引用的成员变量。客户端可通过将处理者传递给上个处理者的构造函数或设定方法来创建链。该类还可以实现默认的处理行为：确定下个处理者存在后再将
 *  请求传递给它。
 * - 具体处理者（Concrete Handlers）包含处理请求的实际代码。每个处理者接收到请求后，都必须决定是否进行处理，以及是否沿着链传递请求。
 *  处理者通常是独立且不可变的， 需要通过构造函数一次性地获得所有必要地数据。
 * - 客户端（Client）可根据程序逻辑一次性或者动态地生成链。值得注意的是，请求可发送给链上的任意一个处理者，而非必须是第一个处理者。
 *
 * @优缺点
 * #优点：
 * - 你可以控制请求处理的顺序。
 * - 单一职责原则。 你可对发起操作和执行操作的类进行解耦。
 * - 开闭原则。 你可以在不更改现有代码的情况下在程序中新增处理者。
 * #缺点：
 * - 部分请求可能未被处理。
 * - 性能问题，每个请求都是从链头遍历到链尾，特别是在链比较长的时候，性能是一个非常大的问题。
 * - 调试不很方便，特别是链条比较长，环节比较多的时候，由于采用了类似递归的方式，调试的时候逻辑可能比较复杂。
 * #注意：
 * - 链中节点数量需要控制，避免出现超长链的情况，一般的做法是在Handler中设置一个最大节点数量，在setNext方法中判断是否已经是超过其阈值，
 *  超过则不允许该链建立，避免无意识地破坏系统性能。
 *
 * @使用场景
 * - 当程序需要使用不同方式处理不同种类请求，而且请求类型和顺序预先未知时，可以使用责任链模式。该模式能将多个处理者连接成一条链。
 *  接收到请求后，它会 “询问” 每个处理者是否能够对其进行处理。这样所有处理者都有机会来处理请求。
 * - 当必须按顺序执行多个处理者时，可以使用该模式。无论你以何种顺序将处理者连接成一条链，所有请求都会严格按照顺序通过链上的处理者。
 * - 如果所需处理者及其顺序必须在运行时进行改变，可以使用责任链模式。如果在处理者类中有对引用成员变量的设定方法，
 *  你将能动态地插入和移除处理者，或者改变其顺序。
 *
 * @思路
 * - 声明处理者接口并描述请求处理方法的签名。
 *  确定客户端如何将请求数据传递给方法。最灵活的方式是将请求转换为对象，然后将其以参数的形式传递给处理函数。
 * - 为了在具体处理者中消除重复的样本代码， 你可以根据处理者接口创建抽象处理者基类。
 *  1.该类需要有一个成员变量来存储指向链上下个处理者的引用。你可以将其设置为不可变类。但如果你打算在运行时对链进行改变，
 *  则需要定义一个设定方法来修改引用成员变量的值。
 *  2.为了使用方便，你还可以实现处理方法的默认行为。如果还有剩余对象，该方法会将请求传递给下个对象。具体处理者还能够通过调用父对象的方法来使用这一行为。
 * - 依次创建具体处理者子类并实现其处理方法。 每个处理者在接收到请求后都必须做出两个决定：
 *  是否自行处理这个请求。
 *  是否将该请求沿着链进行传递。
 * - 客户端可以自行组装链， 或者从其他对象处获得预先组装好的链。 在后一种情况下， 你必须实现工厂类以根据配置或环境设置来创建链。
 * - 客户端可以触发链中的任意处理者， 而不仅仅是第一个。 请求将通过链进行传递， 直至某个处理者拒绝继续传递， 或者请求到达链尾。
 * - 由于链的动态性， 客户端需要准备好处理以下情况：
 *  链中可能只有单个链接。
 *  部分请求可能无法到达链尾。
 *  其他请求可能直到链尾都未被处理。
 */
public class CorClient {
    @Test
    public void testCor() {
        Handler handler1 = new ConcreteHandler();
        Handler handler2 = new ConcreteHandler2();
        Handler handler3 = new ConcreteHandler3();
        handler1.setNext(handler2);
        handler2.setNext(handler3);
        // 发送请求
        String[] requests = {"aaa", "bbb", "ccc", "ddd"};
        for (String request : requests) {
            handler1.handler(request);
        }
    }
}