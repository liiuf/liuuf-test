package liiuf.dp.beh.templete;

import liiuf.dp.beh.templete.exp01.AbstractClass;
import liiuf.dp.beh.templete.exp01.ConcreteClass1;
import liiuf.dp.beh.templete.exp01.ConcreteClass2;
import org.junit.Test;

/**
 * @简介
 * - 定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
 *
 * @分类
 * - 抽象类（AbstractClass） 会声明作为算法步骤的方法， 以及依次调用它们的实际模板方法。 算法步骤可以被声明为抽象类型，
 *  也可以提供一些默认实现，抽象类的方法分为两类，一种为基本方法，主要用于由子类实现的方法，并且在模板方法被调用，一种为模板方法，
 *  可以包含一个或几个，一般是一个具体方法，也就是一个框架，主要用于实现对基本方法的调度，完成固定的逻辑。注意，为了防止恶意的操作，
 *  一般模板方法都加上final关键字，不允许被覆写。
 * - 具体类（ConcreteClass） 可以重写所有步骤即实现父类所定义的一个或多个抽象方法， 但不能重写模板方法自身。
 * - 模板方法模式仅仅使用了Java的继承机制，通过类继承的方式实现。
 *
 * @优缺点
 * #优点
 * - 封装不变部分，扩展可变部分，即仅允许客户端重写一个大型算法中的特定部分， 使得算法其他部分修改对其所造成的影响减小。。
 * - 提取公共部分代码，便于维护，即将重复代码提取到一个超类中。
 * - 行为由父类控制，子类实现，符合开闭原则。
 * #缺点
 * - 部分客户端可能会受到算法框架的限制。
 * - 通过子类抑制默认步骤实现可能会导致违反里氏替换原则。
 * - 模板方法中的步骤越多， 其维护工作就可能会越困难。
 *
 * @使用场景
 * - 当你只希望客户端扩展某个特定算法步骤，而不是整个算法或其结构时，可使用模板方法模式。模板方法将整个算法转换为一系列独立的步骤，
 *  以便子类能对其进行扩展， 同时还可让超类中所定义的结构保持完整。
 * - 当多个类的算法除一些细微不同之外几乎完全一样时，你可使用该模式。但其后果就是，只要算法发生变化，你就可能需要修改所有的类。
 *  在将算法转换为模板方法时，你可将相似的实现步骤提取到超类中以去除重复代码。子类间各不同的代码可继续保留在子类中。
 * - 重构时，模板方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通过钩子函数约束其行为。所谓钩子方法，就是当外界条件改变，
 *  会影响到模板方法的执行。比如在我们的抽象类中增加判断逻辑，然后根据判断逻辑的返回值执行模板方案，从而影响了模板方法的执行结果，
 *  该判断方法就叫做钩子方法（Hook Method）。
 *
 * @思路
 * - 分析目标算法，确定能否将其分解为多个步骤。从所有子类的角度出发，考虑哪些步骤能够通用，哪些步骤各不相同。
 * - 创建抽象基类并声明一个模板方法和代表算法步骤的一系列抽象方法。在模板方法中根据算法结构依次调用相应步骤。可用 final最终修饰模板方法以防止子
 *  类对其进行重写。
 * - 虽然可将所有步骤全都设为抽象类型，但默认实现可能会给部分步骤带来好处，因为子类无需实现那些方法。
 * - 可考虑在算法的关键步骤之间添加钩子。
 * - 为每个算法变体新建一个具体子类，它必须实现所有的抽象步骤，也可以重写部分可选步骤。
 */
public class TemplateClient {
    @Test
    public void testTemplate() {
        AbstractClass ac1 = new ConcreteClass1();
        ac1.templateMethod();
        System.out.println("----------------------------");
        AbstractClass ac2 = new ConcreteClass2();
        ac2.templateMethod();
    }
}